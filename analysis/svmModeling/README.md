## SVM modeling

This folder contains data, scripts, and code to build SVM models for each Prx subgroup, use those models to classify the
*harper* data set protein sequences, and then analyse 63 cases where the classifiers all returned negative scores.

The results of this analysis directly relate to Tables 2, 3, 7, and 8; Figure 1; the corresponding discussions for those tables and figures; supplementary information *Additional file 1*; and much of the other downstream analyses.

---
The most general instructions are to make sure that the following auxiliary programs are available in this folder:
* svm_learn (from the SVM-Light distribution; see the auxiliary programs section in the main README.md)
* svm_classify (from the SVM-Light distribution; see the auxiliary programs section in the main README.md)
* svm2weight.py (see the auxiliary programs section in the main README.md)

and then to run the following two scripts in this order:
* ./buildModel.sh
* ./classifyFullHarper.sh

The results, printed in a confusion matrix, will be in the file: fullHarperConfusionMatrix.txt

Additional code and scripts support the analysis of cases where all classifiers return a negative score. 
This analysis appears in Figure 1 and Table 8 in the manuscript and the related discussion.  

Running the script:
* ./analyzeAllNegative.sh

will find such cases, determine whether they were incorrectly annotated or not by Prx3-merSVM, 
and regenerate (using gnuplot) Figure 1.

A more detailed description is below.

---
### Auxiliary programs needed
* svm_learn (from the SVM-Light distribution; see the auxiliary programs section in the main README.md)
* svm_classify (from the SVM-Light distribution; see the auxiliary programs section in the main README.md)
* svm2weight.py (see the auxiliary programs section in the main README.md)


### Compiling source code (if available)
If you have access to the source code only, then the Java programs can be compiled using the following commands:
```
javac Sequence.java
javac SequenceReader.java
javac KmerMap.java
javac KmerCount.java
javac GenerateKmerMap.java
javac AnalyzeErrors.java
javac CombineScores.java
javac FindNoMatchScores.java
javac GenerateLabel.java
javac GenerateSVMFeatures.java
javac JoinActualPredicted.java
javac LabelTrainSVM.java
javac LabelWithNoLabel.java
javac MapBackWeights.java
```

(alternatively, execute *javac \*.java*)

---
### Executing programs
The scripts to run are, in this order:
```
./buildModel.sh
./classifyFullHarper.sh
./analyzeAllNegative.sh
```
---
### Description of *buildModel.sh*

The script *buildModel.sh* executes six other scripts, in the following order:
```
./bm_1_generateLabels.sh
./bm_2_generateKmerMap.sh
./bm_3_convertToSVMFeatureRepresentations.sh
./bm_4_generateSVMTrainingInput.sh
./bm_5_train.sh
./bm_6_extractWeights.sh
```

The models are built from the *harper_SFLD_95* data set.  Each Prx subgroup is modeled by 
learning from all sequences in that data set, where the sequences that belong to a subgroup have the positive class 
label and all other sequences have the negative class label.

The first script *bm_1_generateLabels.sh*, generates two files for each subgroup (so 12 total) with the appropriate number
of labels (AhpE, NOTAhpE; Prx1, NotPrx1; ...) in each file, where the appropriate number is the number of examples
that are either from the subgroup or are not from the subgroup respectively.  Since there are 4751 total samples in the *harper_SFLD_95*  data set and 138 are *AhpE*, 138 **AhpE** labels are generated into the file *AhpE.label* and 4613 **NOTAhpE** labels are generated into the file *allButAhpE.label*.

The second script *bm_2_generateKmerMap.sh* iterates over all sequences in the entire *harper_SFLD_95* data set and generates a *k-mer map*, a listing of all unique k-mers found in the sequences and a unique id for each.  This is later used in encoding the
sequences to an SVM-Light compatible format.  

The third script *bm_3_convertToSVMFeatureRepresentations.sh* revisits each sequence in the entire *harper_SFLD_95* data set and
converts the sequence to a representation where the count of each k-mer is recorded.  For each sequence, if a k-mer occurs > 0 times, the numerical id for the k-mer (from the k-mer map) is recorded along with how many times it was present. After this conversion, one
training file for each subgroup is generated by concatenating, for each subgroup, the positive and negative examples (in their SVM encoded form) and by concatenating the positve and negative labels.

The fourth script *./bm_4_generateSVMTrainingInput.sh* uses the label files generated in the previous step to prepend a +1 (positive class) or -1 (negative class) label to the SVM-Light compatible training data files.  This is done individually for each subgroup.

The fifth script *./bm_5_train.sh* calls the auxiliary program *svm_learn* to build a linear SVM model for each subgroup based on the training data for each subgroup generated in the previous steps.

The sixth script *./bm_6_extractWeights.sh* uses the auxiliary program *svm2weight.py* to extract from each linear model
the learned weights for each 3-mer and then uses the program *MapBackWeights* with the k-mer map and the learned weights file
to output a file for each subgroup containing, for that subgroup, the weights for each 3-mer.  These weights are sorted from largest
(most positive) to smallest (most negative).

### Description of *classifyFullHarper.sh*

The script *classifyFullHarper.sh* executes four other scripts, in the following order:
```bash
./cfh_1_formatHarperData.sh
./cfh_2_generateRealLabels.sh
./cfh_3_employModels.sh
./cfh_4_combineScores.sh > fullHarperConfusionMatrix.txt
```

The data set being analyzed here is the large *harper* data set.  

The first script *./cfh_1_formatHarperData.sh* uses the k-mer map from the training data and the *harper* data set sequences to encode 
the sequences into the appropriate SVM-Light compatible format.  The process is effectively the same as for the third script
in *buildModel.sh* script,  where for each sequence, if a k-mer occurs > 0 times, the numerical id for the k-mer (from the k-mer map) is recorded along with how many times it was present.  Every sample in the generated training file is associated with a label 0
(instead of +1 or -1) meaning the class is not known.  One file containing the encoded representation of all sequences
in the *harper* data set is generated.

The second script *./cfh_2_generateRealLabels.sh* generates files, one for each subgroup, containing the Harper label for 
each sequence annotated to that subgroup by Harper *et al*. These are then concatenated into one label file for all of the *harper* data set sequences.  This is used in analyzing the Prx_3-merSVM classifications so that the predicted labels can be compared to the Harper labels.

The third script */cfh_3_employModels.sh* uses the auxiliary program *svm_classify* and the six linear models learned (via *./bm_5_train.sh*) to compute six subgroup-specific SVM scores for each sequence in the data set.

The fourth script *./cfh_4_combineScores.sh* combines, for each sequence, the scores from each classifier and finds the maximum score.
Each sequence in the data set is then annotated with the subgroup which is associated with that maximum score.  These Prx_3-merSVM annotations are then joined with the Harper labels.  The Unix *grep* command is then used to extract a confusion matrix highlighting
how often a given sequence was annotated with a given Harper/Prx_3merSVM pair.  Ideally, the Harper/Prx_3-merSVM pair would be the
same annotation (such as AhpE:Ahpe); cases where they do not match were further analyzed. 

The final output is in the file *fullHarperConfusionMatrix.txt* which has a format similar to the following:
```
AhpE:AhpE
1486
AhpE:Prx1
0
AhpE:Prx5
1
AhpE:Prx6
0
AhpE:PrxQ
2
AhpE:Tpx
0
Prx1:AhpE
0
Prx1:Prx1
9660
Prx1:Prx5
0
```

Each pair of lines should be interpreted as the number of protein sequences which had a given Harper and a given Prx_3-merSVM annotation.  For each line *X:Y* the string X represents the Harper annotation and the string Y represents the Prx_3-merSVM annotation.  The number below that line is how many protein sequences had that pair of annotations.  Since there are six possible subgroup annotations, the file will have 72 lines (2 each for the 36 pairs of annotations).

Interpreting the lines above, there were 1486 proteins annotated as AhpE by both Harper and Prx_3-merSVM, 1 annotated as AhpE by Harper but Prx5 by Prx_3-merSVM, 2 annotated as AhpE by Harper but Prx6 by Prx_3-merSVM, and 9660 annotated as Prx1 by both Harper and Prx_3-merSVM.  

### Description of *analyzeAllNegative.sh*

The script *analyzeAllNegative.sh* contains the following set of commands:
```bash
java FindNoMatchScores scoreDB.txt allNegativeScoresCases.txt
sort -k1,1g allNegativeScoresCases.txt > allNegativeScoresCasesSorted.txt
java AnalyzeErrors allNegativeScoresCasesSorted.txt fullHarperAll.label allNegativeCorrectData.txt allNegativeIncorrectData.txt
gnuplot < graphAllNegativeAnalysis.gp
```

The program *FindNoMatchScores* searches through the files (listed in *scoreDB.txt*) that contain the scores from each subgroup classifier for each protein classified to find any instances where all of the classifiers returned a negative score.  The output is similar to the following:

```
-0.23111163 AhpE 23
-0.093929422 AhpE 33
-0.43084863 Prx5 47
-0.13559649 AhpE 71
```

Each line contains the maximum score for the instance (out of the scores provided from the six classifiers), the label that was associated with that maximum score, and the index of the sequence in the list of sequences being classified.  These are then sorted by the first column (the score column).  

The program *AnalyzeErrors* takes the error cases in the *allNegativeScoresCasesSorted.txt* file and compares the suggested annotation to the Harper annotation provided in the file *fullHarperAll.label*, a file that was generated earlier in the SVM modeling process.  For cases where the suggested Prx_3-merSVM annotation matches the Harper annotation, the score and an index within the all negative cases is written to the *allNegativeCorrectData.txt* file.  For cases where the suggested Prx_3-merSVM annotation does not match the Harper annotation, the score and an index within the all negative cases is written to the *allNegativeInCorrectData.txt* file.  An example of the outputs are below.

*allNegativeCorrectData.txt*
```
1 -0.44927172
4 -0.31703388
5 -0.31404255
7 -0.27734985
```

*allNegativeIncorrectData.txt*
```
2 -0.43084863
3 -0.40877999
6 -0.28852631
```

Those outputs suggest that, of the cases where all the classifiers returned a negative score (there were 63 in the analyis), when the instances are sorted by score, the 1st, 4th, 5th, and 7th all still had a Prx_3-merSVM annotation that matched the Harper annotation, while the 2nd, 3rd, and 6th instances had Prx_3-merSVM annotation that did not match the Harper annotation.

These two files are used to create *Figure 1* in the manuscript
